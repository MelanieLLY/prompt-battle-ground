# Challenge 1: Email validation function with regex



**Deliverables:** This document records each prompt version, test results for the generated code, custom test-case results, prompt improvement notes, and code quality comparison.



## v1

![v1 screenshot](v1%20screenshot.png)

### Prompt
Write a webapp with just a simple TypeScript function to validate email addresses using a regex. Include a 'try your own' part so I can put my own test cases.
Format: Output a artifact with the function and a small set of tests runnable via a test button.
### Test cases generated by Claude

| Email | Expected | Got | Result |
|-------|----------|-----|--------|
| `user@example.com` | true | true | ✓ PASS |
| `test.email@domain.co.uk` | true | true | ✓ PASS |
| `invalid@` | false | false | ✓ PASS |
| `@invalid.com` | false | false | ✓ PASS |
| `no-at-sign.com` | false | false | ✓ PASS |
| `spaces in@email.com` | false | false | ✓ PASS |
| `user@domain` | false | false | ✓ PASS |

**7 / 7 tests passed**

### Test cases input by myself

| Note | Email | Expected | Got | Result |
|------|-------|----------|-----|--------|
| standard email | `simple@example.com` | true | true | ✓ PASS |
| multiple domain levels | `user.name@domain.co.uk` | true | true | ✓ PASS |
| plus tagging | `user+mailbox@gmail.com` | true | true | ✓ PASS |
| numeric local part | `123456@provider.net` | true | true | ✓ PASS |
| hyphenated and long TLD | `customer-service@store.online` | true | true | ✓ PASS |
| consecutive dots in local part | `example..test@domain.com` | false | true | ✗ FAIL |
| starts with a dot | `.user@domain.com` | false | true | ✗ FAIL |
| ends with a dot | `user.@domain.com` | false | true | ✗ FAIL |
| consecutive dots in domain | `user@domain..com` | false | true | ✗ FAIL |
| TLD too short | `user@domain.c` | false | true | ✗ FAIL |
| TLD cannot be numeric | `user@domain.123` | false | true | ✗ FAIL |
| contains space | `user @domain.com` | false | false | ✓ PASS |
| missing local part | `@domain.com` | false | false | ✓ PASS |
| missing TLD | `user@domain` | false | false | ✓ PASS |
| domain starts with a dot | `user@.com` | false | false | ✓ PASS |
| contains invalid character # | `user#name@domain.com` | false | true | ✗ FAIL |

**9 / 16 tests passed**

## v2

![v2 screenshot](v2%20screenshot.png)

### Prompt
You are a senior TypeScript developer.

Task

Implement a artifact with a simple function isValidEmail(email: string): boolean using one regex (no external libs).

Must accept

plus addressing: a+b@x.com

subdomains: a@b.c.d.com

dots in local part: a.b@x.com

Must reject

missing @, multiple @

any whitespace

consecutive dots in local part (a..b@x.com)

local part starts/ends with dot (.a@x.com, a.@x.com)

domain label starts/ends with hyphen (a@-x.com, a@x-.com)

TLD length < 2 (a@x.c)

Tests

Include at least 24 test cases (12 valid, 12 invalid) in an array and a minimal runner that prints PASS/FAIL and exits non-zero if any fail.

Include a 'try your own' part that takes multiple test cases, this part should (1)ignore content inside the first brackets because that's only my personal note (2) take the first word 'true' or /false/ as the test expected result. for example, I will input things like:
(standard email) true simple@example.com
(multiple domain levels) true user.name@domain.co.uk

Output format

Return one interactive artifact

### Test cases generated by Claude

**24 / 24 tests passing**

| Email | Description | Expected | Got | Result |
|-------|-------------|----------|-----|--------|
| `simple@example.com` | Basic email | true | true | PASS |
| `user+tag@example.com` | Plus addressing | true | true | PASS |
| `user+123@example.com` | Plus with numbers | true | true | PASS |
| `first.last@example.com` | Dot in local part | true | true | PASS |
| `a.b.c@example.com` | Multiple dots in local | true | true | PASS |
| `user@sub.example.com` | Subdomain | true | true | PASS |
| `user@a.b.c.d.com` | Multiple subdomains | true | true | PASS |
| `test123@example.co` | Two letter TLD | true | true | PASS |
| `user@domain.co.uk` | Country TLD | true | true | PASS |
| `a@b.com` | Minimal valid email | true | true | PASS |
| `user@ex-ample.com` | Hyphen in domain | true | true | PASS |
| `user.name+tag@sub.domain.example.com` | Complex valid | true | true | PASS |
| `plaintext` | Missing @ | false | false | PASS |
| `user@@example.com` | Multiple @ | false | false | PASS |
| `user@exam ple.com` | Space in domain | false | false | PASS |
| `us er@example.com` | Space in local | false | false | PASS |
| `user..name@example.com` | Consecutive dots | false | false | PASS |
| `.user@example.com` | Starts with dot | false | false | PASS |
| `user.@example.com` | Ends with dot | false | false | PASS |
| `user@-example.com` | Domain starts with hyphen | false | false | PASS |
| `user@example-.com` | Domain ends with hyphen | false | false | PASS |
| `user@example.c` | TLD too short | false | false | PASS |
| `user@.com` | Missing domain label | false | false | PASS |
| `@example.com` | Missing local part | false | false | PASS |

### Test cases input by myself

**15 / 16 passing** (only `customer-service@store.online` wrongly rejected)

| Note | Email | Expected | Got | Result |
|------|-------|----------|-----|--------|
| standard email | `simple@example.com` | true | true | PASS |
| multiple domain levels | `user.name@domain.co.uk` | true | true | PASS |
| plus tagging | `user+mailbox@gmail.com` | true | true | PASS |
| numeric local part | `123456@provider.net` | true | true | PASS |
| hyphenated and long TLD | `customer-service@store.online` | true | false | **FAIL** |
| consecutive dots in local part | `example..test@domain.com` | false | false | PASS |
| starts with a dot | `.user@domain.com` | false | false | PASS |
| ends with a dot | `user.@domain.com` | false | false | PASS |
| consecutive dots in domain | `user@domain..com` | false | false | PASS |
| TLD too short | `user@domain.c` | false | false | PASS |
| TLD cannot be numeric | `user@domain.123` | false | false | PASS |
| contains space | `user @domain.com` | false | false | PASS |
| missing local part | `@domain.com` | false | false | PASS |
| missing TLD | `user@domain` | false | false | PASS |
| domain starts with a dot | `user@.com` | false | false | PASS |
| contains invalid character # | `user#name@domain.com` | false | false | PASS |

## v3

![v3 screenshot](v3%20screenshot.png)

### Prompt
You are a senior TypeScript developer writing production-quality validation utilities.

<context>
The goal is a practical email validator that is:

correct for common real-world emails,

safe (avoid catastrophic backtracking),

and maintainable (regex built from named subpatterns).
</context>

<task>
Create an interactive Artifact containing:

export function isValidEmail(email: string): boolean

A test runner with a Run Tests button

A “Try your own” multiline input area that parses my custom cases
</task>

<functional_requirements>
Implement validation using one combined regex constructed from named subpatterns (string constants) like LOCAL_PART, DOMAIN, TLD, etc. No external libraries.

Must accept (in addition to v2):

long TLDs (e.g., .online, .technology) — TLD length 2 to 63, letters only

hyphens in local part (e.g., customer-service@store.online)

underscores in local part (e.g., first_last@domain.com)

uppercase letters anywhere (should be treated as valid)

deep subdomain chains (e.g., a@b.c.d.e.f.g.example.com)

Must reject (keep all v2 rejects):

missing @, multiple @

any whitespace anywhere

consecutive dots in local part (a..b@x.com)

local part starts/ends with dot (.a@x.com, a.@x.com)

consecutive dots in domain (a@x..com)

domain label starts/ends with hyphen (a@-x.com, a@x-.com)

domain label empty (a@.com, a@com.)

TLD length < 2

numeric-only TLD (e.g., .123)

quoted local parts are out of scope: "a b"@x.com must be invalid

invalid characters in local part such as ()[]\ and #
</functional_requirements>

<character_rules>
Local part allowed chars (do NOT mention as “RFC complete”): letters, digits, and ._%+- plus underscore _

Domain labels allowed: letters/digits with internal hyphens, separated by dots

TLD allowed: letters only, length 2–63
</character_rules>

<tests>
Include:

The same 24 test cases from v2 (12 valid + 12 invalid), with the same expected results and descriptions.

Add 6 more edge cases (total 30) and include these specific ones:

customer-service@store.online → valid

FIRST_LAST@Example.COM → valid

a@b.c.d.e.f.g.example.com → valid

"a b"@example.com → invalid

user@[123]@example.com (or any local with []) → invalid

user@domain.technology → valid
</tests>

<try_your_own>
Provide a multiline input where each line looks like:

(my note) true simple@example.com

(another note) false user..name@example.com

Parsing rules:

Ignore anything inside the first parentheses (...) if present

Read the first standalone token true or false as expected result

The remaining token is the email string (no spaces inside; if spaces appear, treat as part of the email and it should fail because whitespace is invalid)
</try_your_own>

<output_constraints>
Return one interactive Artifact (not a plain .ts file)

Keep comments short and practical:

briefly explain each subpattern and what it allows/forbids

Keep the regex linear and avoid nested ambiguous quantifiers that could cause catastrophic backtracking.
</output_constraints>

<planning>
Before writing any code, spend a moment to think or plan: outline the regex structure (named subpatterns for LOCAL_PART, DOMAIN, TLD), the accept/reject matrix, edge cases (long TLDs, hyphens/underscores, deep subdomains), and how to keep the regex safe from catastrophic backtracking. 
</planning>


### Test cases generated by Claude

**30 / 30 passed**

| Email | Description |
|-------|-------------|
| `simple@example.com` | Basic valid email |
| `user.name@example.com` | Dot in local part |
| `user+tag@example.co.uk` | Plus sign and ccTLD |
| `first.last@sub.domain.com` | Subdomain |
| `user%test@example.com` | Percent in local part |
| `a@b.co` | Minimal valid email |
| `test@example.museum` | Long TLD |
| `user-name@example.com` | Hyphen in local part |
| `first_last@example.com` | Underscore in local part |
| `TEST@EXAMPLE.COM` | Uppercase letters |
| `user@mail.example.com` | Multiple subdomains |
| `123@example.com` | Numeric local part |
| `plainaddress` | Missing @ |
| `@example.com` | Missing local part |
| `user@` | Missing domain |
| `user @example.com` | Space in email |
| `user@example .com` | Space in domain |
| `user..name@example.com` | Consecutive dots in local |
| `.user@example.com` | Leading dot in local |
| `user.@example.com` | Trailing dot in local |
| `user@.example.com` | Leading dot in domain |
| `user@example..com` | Consecutive dots in domain |
| `user@-example.com` | Leading hyphen in domain |
| `user@example.c` | TLD too short |
| `customer-service@store.online` | Hyphen and long TLD |
| `FIRST_LAST@Example.COM` | Mixed case with underscore |
| `a@b.c.d.e.f.g.example.com` | Deep subdomain chain |
| `"a b"@example.com` | Quoted string (unsupported) |
| `user[123]@example.com` | Brackets in local part |
| `user@domain.technology` | Very long TLD |

### Test cases input by myself

**16 / 16 passed**

| Note | Email |
|------|-------|
| standard email | `simple@example.com` |
| multiple domain levels | `user.name@domain.co.uk` |
| plus tagging | `user+mailbox@gmail.com` |
| numeric local part | `123456@provider.net` |
| hyphenated and long TLD | `customer-service@store.online` |
| consecutive dots in local part | `example..test@domain.com` |
| starts with a dot | `.user@domain.com` |
| ends with a dot | `user.@domain.com` |
| consecutive dots in domain | `user@domain..com` |
| TLD too short | `user@domain.c` |
| TLD cannot be numeric | `user@domain.123` |
| contains space | `user @domain.com` |
| missing local part | `@domain.com` |
| missing TLD | `user@domain` |
| domain starts with a dot | `user@.com` |
| contains invalid character # | `user#name@domain.com` |


## What made prompts better

### v1 → v2

- **Role and constraints:** Specify “You are a senior TypeScript developer” and “one regex, no external libs” to reduce ambiguity and avoid extra dependencies.
- **Explicit accept/reject list:** Write rules like “plus addressing, subdomains, dots in local part” and “consecutive dots, leading/trailing dot, domain hyphen, TLD length” as Must accept / Must reject so the model implements them by checklist and reduces missed cases.
- **Test count and format:** Require “at least 24 cases (12 valid + 12 invalid)” and “PASS/FAIL, exit non-zero,” and define the “Try your own” parsing (parentheses = note, first true/false = expected result) for consistent comparison.
- **Why we iterated:** v1 ran 9/16 on custom cases, exposing gaps (consecutive dots, leading/trailing dots, TLD length/numeric, `#`), which we turned into explicit rules in v2.

### v2 → v3

- **Context and goals:** State “production-quality,” “correct / safe / maintainable” so the model considers safety and maintainability, not only correctness.
- **Safety and maintainability:** Require “avoid catastrophic backtracking” and “regex built from named subpatterns (LOCAL_PART, DOMAIN, TLD)” so the implementation moves from one long regex to composed subpatterns that are easier to read and change.
- **Extended accept rules:** Add “long TLD (2–63 letters),” “hyphen/underscore in local part,” “uppercase,” “deep subdomains,” and clarify “quoted local and invalid chars = reject,” “numeric-only TLD = reject.”
- **Cases and parsing:** Keep v2’s 24 cases and add 6 (e.g. `customer-service@store.online`, `FIRST_LAST@Example.COM`, deep subdomains, quoted, brackets), and restate “Try your own” format so custom cases stay reusable across versions.
- **Why we iterated:** v2 incorrectly rejected `customer-service@store.online` (hyphen in local not in v2 rules); v3 added that rule and used named subpatterns, and all 16 custom cases pass.

### Summary: what makes prompts more effective

- **Explicit accept/reject lists** are more reliable than “handle edge cases.”
- **Fixed test count, format, and parsing rules** make it easy to compare versions with the same cases.
- **Real failing cases** drive the next version (v1’s 7 failures → v2 rules; v2’s hyphen false negative → v3 rules), so iteration is traceable.
- When you need **safety and maintainability**, stating “no catastrophic backtracking” and “named subpatterns” in the prompt directly changes the implementation.



## Code quality comparison

| Dimension | v1 | v2 | v3 |
|-----------|----|----|-----|
| **Regex style** | Single loose regex `[^\s@]+@[^\s@]+\.[^\s@]+`, no local/domain/TLD split | One long regex with clear structure (local + optional plus, domain labels, TLD 2+ letters) | Named subpatterns `LOCAL_CHAR` / `LOCAL_PART` / `LABEL_CHAR` / `DOMAIN_LABELS` / `TLD` composed; easy to read and change |
| **Boundaries & safety** | Regex only; misses consecutive dots, leading/trailing dots, numeric TLD, etc. | Stricter regex; still possible backtracking risk | Quick checks first (whitespace, `..`, `@` count, leading/trailing dots, invalid chars, numeric TLD), then regex; less backtracking and fewer misses |
| **Input validation** | No type/empty check on `email` | None | `!email \|\| typeof email !== 'string'` early return for robustness |
| **Built-in cases** | 7, mostly basic | 24 (12 valid + 12 invalid), plus, subdomain, dots, hyphen, TLD | 30; adds long TLD, hyphen/underscore in local, deep subdomains, quoted, brackets |
| **Try your own parsing** | Parentheses + true/false; logic differs slightly from v2/v3 | Explicit “ignore parentheses, first true/false = expected, rest = email” | Same as v2; aligned with testcases.md; multiline batch |

**Conclusion:** v1 is good for a quick “regex + tests” check; v2 strengthens rules and case count and works as a correctness baseline; v3 keeps high pass rate while improving maintainability (named subpatterns), safety (pre-checks + less backtracking), and reuse (export, input checks), and passes all 16 custom cases.



## Test results summary

| Version | Model-generated cases | Custom cases (testcases.md, 16) |
|---------|------------------------|--------------------------------|
| v1 | 7/7 pass | 9/16 pass (misses: consecutive dots, leading/trailing dots, TLD too short/numeric, `#`) |
| v2 | 24/24 pass | 15/16 pass  |
| v3 | 30/30 pass | 16/16 pass |